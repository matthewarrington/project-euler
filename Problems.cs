namespace project_euler
{
    using System;
    using System.Collections.Generic;
    using System.Linq;

    internal static partial class Problem
    {
        //--------------------------------------------------
        // https://projecteuler.net/problem=1
        //
        // If we list all the natural numbers below 10 that are multiples of 3 or 5,
        // we get 3, 5, 6 and 9. The sum of these multiples is 23.
        // Find the sum of all the multiples of 3 or 5 below 1000.
        //--------------------------------------------------
        public static (int, string) P0001()
        {
            var result = 0;
            for(var i = 0; i < 1000; i++)
            {
                if (i % 3 == 0 || i % 5 == 0)
                {
                    result += i;
                }
            }
            return (1, result.ToString());
        }

        //--------------------------------------------------
        // https://projecteuler.net/problem=2
        //
        // Each new term in the Fibonacci sequence is generated by adding the previous
        // two terms. By starting with 1 and 2, the first 10 terms will be:
        //
        //      1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
        //
        // By considering the terms in the Fibonacci sequence whose values do not exceed
        // four million, find the sum of the even-valued terms.
        //--------------------------------------------------
        // Notes:
        // I guess this would classically be a recursive function, but I want to write
        // a sequence generator.       
        //--------------------------------------------------
        public static (int, string) P0002()
        {
            var result = Functions.Fibonacci(1, 2)
                .TakeWhile(x => x <= 4000000)
                .Where(x => x % 2 == 0)
                .Sum(x => x)
                .ToString();

            return (2, result);
        }

        //--------------------------------------------------
        // https://projecteuler.net/problem=3
        //
        // The prime factors of 13195 are 5, 7, 13 and 29.
        //
        // What is the largest prime factor of the number 600851475143?
        //--------------------------------------------------
        // Plan:
        //  1. Find next prime (as before, use a generator because fun and
        //     convenient)
        //  2. Test if target is divisible by prime, reducing target by
        //     all occurrences
        //  3. Repeat, stop when target is equal to the current prime?
        //     (Stop when target == 1, simpler loop logic)
        //--------------------------------------------------
        public static (int, string) P0003()
        {
            var target = 600851475143;

            foreach(var p in Functions.Primes().Take(1000))
            {
                while (target % p == 0)
                {
                    target /= p;
                }
                if (target == 1)
                {
                    return (3, p.ToString());
                }
            }

            throw new Exception("Ran out of primes without resolution.");
        }

        //--------------------------------------------------
        // https://projecteuler.net/problem=4
        //
        // A palindromic number reads the same both ways. The largest palindrome
        // made from the product of two 2-digit numbers is 9009 = 91 Ã— 99.
        //
        // Find the largest palindrome made from the product of two 3-digit
        // numbers.
        //--------------------------------------------------
        // Plan:
        //  * I don't know enough about mathematics to casually know the
        //    numeric patterns that would lead to this. I'm going to try
        //    making it a search problem.
        //  * "PNum" = Palindromic Number
        //  1. Fabricate pnums, starting with the largest possible (999999)
        //     a. Create it from a three digit number, repeated
        //     b. Start with 999, decrement as that fails, etc
        //  2. Make guesses for two numbers
        //     a. Start with the sqrt of the pnum, truncated
        //     b. Take the product of this A * B and compare it to the pnum
        //        * If the product is too small, increment A
        //        * If the product is too large, decrement B
        //     c. Stop when:
        //        * Victory: The product == pnum
        //        * Defeat: A or B is no longer 3 digits
        //  3. Try different pnums until we're out of 6-digit numbers
        //--------------------------------------------------
        public static (int, string) P0004()
        {
            foreach(var pNum in GeneratePalindromes())
            {
                var a = (int)Math.Sqrt(pNum);
                var b = a;

                while (a <= 999 && b >= 100)
                {
                    var product = a * b;

                    if (product == pNum)
                    {
                        return (4, product.ToString());
                    }
                    else if (product < pNum)
                    {
                        a++;
                    }
                    else
                    {
                        b--;
                    }
                }
            }

            throw new Exception("Ran out of palindromes without resolution.");
        }

        private static int ReverseInt(int i)
        {
            var result = 0;
            while(i > 0)
            {
                result = result * 10 + i % 10;
                i /= 10;
            }
            return result;
        }

        private static IEnumerable<int> GeneratePalindromes()
        {
            var seed = 999;

            while (seed >= 100)
            {
                yield return seed * 1000 + ReverseInt(seed);
                seed--;
            }
        }
    }
}