namespace project_euler
{
    using System;
    using System.Collections.Generic;
    using System.Linq;

    internal static partial class Problem
    {
        //--------------------------------------------------
        // https://projecteuler.net/problem=1
        //
        // If we list all the natural numbers below 10 that are multiples of 3 or 5,
        // we get 3, 5, 6 and 9. The sum of these multiples is 23.
        // Find the sum of all the multiples of 3 or 5 below 1000.
        //--------------------------------------------------
        public static (int, string) P0001()
        {
            var result = 0;
            for(var i = 0; i < 1000; i++)
            {
                if (i % 3 == 0 || i % 5 == 0)
                {
                    result += i;
                }
            }
            return (1, result.ToString());
        }

        //--------------------------------------------------
        // https://projecteuler.net/problem=2
        //
        // Each new term in the Fibonacci sequence is generated by adding the previous
        // two terms. By starting with 1 and 2, the first 10 terms will be:
        //
        //      1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
        //
        // By considering the terms in the Fibonacci sequence whose values do not exceed
        // four million, find the sum of the even-valued terms.
        //--------------------------------------------------
        // Notes:
        // I guess this would classically be a recursive function, but I want to write
        // a sequence generator.       
        //--------------------------------------------------
        public static (int, string) P0002()
        {
            var result = Functions.Fibonacci(1, 2)
                .TakeWhile(x => x <= 4000000)
                .Where(x => x % 2 == 0)
                .Sum(x => x)
                .ToString();

            return (2, result);
        }

        //--------------------------------------------------
        // https://projecteuler.net/problem=3
        //
        // The prime factors of 13195 are 5, 7, 13 and 29.
        //
        // What is the largest prime factor of the number 600851475143?
        //--------------------------------------------------
        // Plan:
        //  1. Find next prime (as before, use a generator because fun and
        //     convenient)
        //  2. Test if target is divisible by prime, reducing target by
        //     all occurrences
        //  3. Repeat, stop when target is equal to the current prime?
        //     (Stop when target == 1, simpler loop logic)
        //--------------------------------------------------
        public static (int, string) P0003()
        {
            var target = 600851475143;

            foreach(var p in Functions.Primes().Take(1000))
            {
                while (target % p == 0)
                {
                    target /= p;
                }
                if (target == 1)
                {
                    return (3, p.ToString());
                }
            }

            throw new Exception("Ran out of primes without resolution.");
        }

        //--------------------------------------------------
        // https://projecteuler.net/problem=4
        //
        // A palindromic number reads the same both ways. The largest palindrome
        // made from the product of two 2-digit numbers is 9009 = 91 × 99.
        //
        // Find the largest palindrome made from the product of two 3-digit
        // numbers.
        //--------------------------------------------------
        // Plan:
        //  * I don't know enough about mathematics to casually know the
        //    numeric patterns that would lead to this. I'm going to try
        //    making it a search problem.
        //  * "PNum" = Palindromic Number
        //  1. Fabricate pnums, starting with the largest possible (999999)
        //     a. Create it from a three digit number, repeated
        //     b. Start with 999, decrement as that fails, etc
        //  2. Make guesses for two numbers
        //     a. Start with the sqrt of the pnum, truncated
        //     b. Take the product of this A * B and compare it to the pnum
        //        * If the product is too small, increment A
        //        * If the product is too large, decrement B
        //     c. Stop when:
        //        * Victory: The product == pnum
        //        * Defeat: A or B is no longer 3 digits
        //  3. Try different pnums until we're out of 6-digit numbers
        //--------------------------------------------------
        public static (int, string) P0004()
        {
            foreach(var pNum in GeneratePalindromes())
            {
                var a = (int)Math.Sqrt(pNum);
                var b = a;

                while (a <= 999 && b >= 100)
                {
                    var product = a * b;

                    if (product == pNum)
                    {
                        return (4, product.ToString());
                    }
                    else if (product < pNum)
                    {
                        a++;
                    }
                    else
                    {
                        b--;
                    }
                }
            }

            throw new Exception("Ran out of palindromes without resolution.");
        }

        private static IEnumerable<int> GeneratePalindromes()
        {
            var seed = 999;

            while (seed >= 100)
            {
                yield return seed * 1000 + Functions.ReverseInt(seed);
                seed--;
            }
        }

        //--------------------------------------------------
        // https://projecteuler.net/problem=5
        //
        // 2520 is the smallest number that can be divided by each of the numbers
        // from 1 to 10 without any remainder.
        //
        // What is the smallest positive number that is evenly divisible by all
        // of the numbers from 1 to 20?
        //--------------------------------------------------
        // Plan:
        //  * Find the set of factors for each input. Make a new set of factors,
        //    composed of the highest count of each factor among the set. Result
        //    is the product of the new set of factors.
        //    TODO: Come up with a better explanation. Factor factor factor.
        //--------------------------------------------------
        public static (int, string) P0005()
        {
            // "factors" is x[factor] = counts;
            var factors = new Dictionary<int, int>();
            for(int i = 20; i > 1; i--)
            {
                factors.MergeFactors(Functions.Factor(i));
            }

            var result = factors.Keys
                .Aggregate(1, (product, factor) => product * (int)Math.Pow(factor, factors[factor])
                );

            return (5, result.ToString());
        }

        private static void MergeFactors(this Dictionary<int, int> factors, Dictionary<int, int> newFactors)
        {
            foreach(var nk in newFactors.Keys)
            {
                if (!factors.ContainsKey(nk) || factors[nk] < newFactors[nk])
                {
                    factors[nk] = newFactors[nk];
                }
            }
        }

        //--------------------------------------------------
        // https://projecteuler.net/problem=6
        //
        // The sum of the squares of the first ten natural numbers is,
        //
        //          1^2 + 2^2 + ... + 10^2 = 385
        //
        // The square of the sum of the first ten natural numbers is,
        //
        //          (1 + 2 + ... + 10)^2 = 55^2 = 3025
        //
        // Hence the difference between the sum of the squares of the first ten natural
        // numbers and the square of the sum is
        //
        //          3025 - 385 = 2640
        //
        // Find the difference between the sum of the squares of the first one hundred
        // natural numbers and the square of the sum.
        //--------------------------------------------------
        // Plan:
        //  * Brute force
        //--------------------------------------------------
        public static (int, string) P0006()
        {
            var max = 100;
            var sumOfSquares = Enumerable.Range(1, max).Select(x => (int)Math.Pow(x, 2)).Sum();
            var squareOfSums = (int)Math.Pow(Enumerable.Range(1, max).Sum(), 2);

            return (6, (squareOfSums - sumOfSquares).ToString());
        }

        //--------------------------------------------------
        // https://projecteuler.net/problem=7
        //
        // By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can
        // see that the 6th prime is 13.
        //
        // What is the 10 001st prime number?
        //--------------------------------------------------
        // Plan:
        //  * Reuse earlier function
        //  * TODO: This took 3.2s... do we need something faster?
        //--------------------------------------------------
        public static (int, string) P0007()
        {
            var result = Functions.Primes().Take(10001).Last();

            return (7, result.ToString());
        }

        //--------------------------------------------------
        // https://projecteuler.net/problem=8
        //
        // The four adjacent digits in the 1000-digit number that have the greatest
        // product are 9 × 9 × 8 × 9 = 5832.
        //
        //         73167176531330624919225119674426574742355349194934
        //         96983520312774506326239578318016984801869478851843
        //         85861560789112949495459501737958331952853208805511
        //         12540698747158523863050715693290963295227443043557
        //         66896648950445244523161731856403098711121722383113
        //         62229893423380308135336276614282806444486645238749
        //         30358907296290491560440772390713810515859307960866
        //         70172427121883998797908792274921901699720888093776
        //         65727333001053367881220235421809751254540594752243
        //         52584907711670556013604839586446706324415722155397
        //         53697817977846174064955149290862569321978468622482
        //         83972241375657056057490261407972968652414535100474
        //         82166370484403199890008895243450658541227588666881
        //         16427171479924442928230863465674813919123162824586
        //         17866458359124566529476545682848912883142607690042
        //         24219022671055626321111109370544217506941658960408
        //         07198403850962455444362981230987879927244284909188
        //         84580156166097919133875499200524063689912560717606
        //         05886116467109405077541002256983155200055935729725
        //         71636269561882670428252483600823257530420752963450
        //
        // Find the thirteen adjacent digits in the 1000-digit number that have the
        // greatest product. What is the value of this product?
        //--------------------------------------------------
        // Plan:
        //  * Walk the number-string as an array and push/pop values through a
        //    buffer to represent the adjacent value.
        //  * Calculate the product after each push, retain the best value.
        //  * Was going to try to avoid recalculating the product but the zero
        //    value makes for some gymnastics there. It's not slow to just
        //    recalculate the product.
        //--------------------------------------------------
        public static (int, string) P0008()
        {
            var bigNumber = "7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450";
            var numbers = bigNumber.Select(x => (Int64)char.GetNumericValue(x)).ToList();
            
            var bufferSize = 13;
            var buffer = numbers.Take(bufferSize).ToList();
            var bestProduct = buffer.Aggregate(1L, (product, x) => product * x);
            foreach(var n in numbers.Skip(bufferSize))
            {
                buffer.RemoveAt(0);
                buffer.Add(n);
                var currentProduct = buffer.Aggregate(1L, (product, x) => product * x);
                //Console.WriteLine($"Current = {currentProduct}, vals = " + string.Join(',', buffer.Select(x => x.ToString())));
                if (currentProduct > bestProduct)
                {
                    bestProduct = currentProduct;
                }
            }

            return (8, bestProduct.ToString());
        }
        
        //--------------------------------------------------
        // https://projecteuler.net/problem=9
        //
        // A Pythagorean triplet is a set of three natural numbers, a < b < c, for
        // which,
        //
        //      a^2 + b^2 = c^2
        //
        // For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.
        //
        // There exists exactly one Pythagorean triplet for which a + b + c = 1000.
        // Find the product abc.
        //--------------------------------------------------
        // Plan:
        //  * Some quick analysis of this problem yields a couple interesting points
        //      * For this analysis, D = A + B + C, and E = A^2 + B^2
        //      * Given the constraints, we're going to have a relationship between
        //        A and B. We see a pattern with how their sum-of-squares will unfold.
        //        Example, where A + B = 10:
        // 
        //          A |  B |  A^2 + B^2
        //         ---+----+-------------
        //          0 | 10 |  0
        //          1 |  9 | 81
        //          2 |  8 | 68
        //          3 |  7 | 58
        //          4 |  6 | 52
        //          5 |  5 | 50
        //
        //        The pattern is that the closer A and B are, the smaller the sum-of-
        //        squares will be. The pattern means we might be able to turn this
        //        into a search problem.
        //      * Also from the above, we see as A and B diverge, E increases dramatically.
        //        A large single B value is increasingly more powerful than an equal
        //        contribution of two smaller values.
        //      * If A = B and E > C^2, no other values of A or B will work (assuming D
        //        stays true).
        //      * If C >= A + B, E will always be < C^2. That means it's not even worth
        //        checking extremes like C = 900.
        //      * Just the above points let us cut down the brute force space a lot.
        //  * Algorithm:
        //      * Start with close values, A ≈ B ≈ C. Maintaining A < B < C, this boils
        //        down to B = (D / 3); A = B - 1; C = D - A - B;
        //      * This will start with the smallest C^2 and smallest E we can possibly
        //        have.
        //      * Test E = C^2:
        //          * Check problem constraints first
        //          * If E = C^2, stop -- we succeeded
        //          * If C > A + B, stop -- we failed
        //          * If E < C^2, we might be able to increase it (A--, B++)
        //          * If E > C^2, we can't get any smaller for this C (C++)
        //      * We might be able to binary search rather than increment, but that's
        //        more complexity than we probably need.
        //--------------------------------------------------
        public static (int, string) P0009()
        {
            const int D = 1000;
            int A, B;
            int C = D - (D * 2 / 3) + 1;
            (A, B) = ResetAB(C, D);

            do
            {
                int E = Sq(A) + Sq(B);
                int SqC = Sq(C);

                //Console.WriteLine($"{A}, {B}, {C}, {E}, {SqC}, {A*B*C}");
                Assert((A + B + C) == D, "Violated A + B + C");
                Assert(A < B && B < C, "Violated A < B < C");

                if (E == SqC)
                {
                    return (9, (A*B*C).ToString());
                }

                if (E < SqC)
                {
                    A--;
                    B++;
                }

                if (E > SqC || B >= C)
                {
                    C++;
                    (A, B) = ResetAB(C, D);
                }
            }
            while(C < A + B);

            throw new Exception("Failed without resolution");

            (int A, int B) ResetAB(int C, int D) {
                var A = (D - C) / 2;
                var B = D - C - A;
                if (A == B) {
                    A--;
                    B++;
                }
                return (A, B);
            }
            int Sq(int x) {
                return (int)Math.Pow(x, 2);
            }
        }

        private static void Assert(bool condition, string message)
        {
            if (!condition) {
                throw new Exception(message);
            }
        }
    }
}