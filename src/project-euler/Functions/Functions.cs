using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;

namespace project_euler
{
    public static class Functions
    {
        public static IEnumerable<int> Fibonacci(int a, int b)
        {
            yield return a;

            while (true)
            {
                yield return b;
                (a, b) = (b, a + b);
            }
        }

        // The version I wrote of this in JS runs in a fraction of the time
        // in Chrome. Replacing "yield return" with a real collection makes
        // up the difference. It generates primes under 2m in 0.8s, which
        // seems fast enough for now.
        public static IEnumerable<int> Primes()
        {
            yield return 2;

            var primes = new List<int>() { 2 };
            var possiblePrime = 3;

            while (true)
            {
                var isPrime = true;
                var stopValue = Math.Sqrt(possiblePrime);
                var primesLen = primes.Count;
                for (int i = 0; i < primesLen; i++)
                {
                    var knownPrime = primes[i];
                    if (knownPrime > stopValue)
                    {
                        break;
                    }
                    else if (possiblePrime % knownPrime == 0)
                    {
                        isPrime = false;
                        break;
                    }
                }

                if (isPrime)
                {
                    primes.Add(possiblePrime);
                    yield return possiblePrime;
                }

                possiblePrime += 2;
            }
        }

        // Returns: Keys = prime factor, Value = count of occurrences
        public static Dictionary<int, int> Factor(long i)
        {
            var result = new Dictionary<int, int>();
            foreach (var p in Functions.Primes().TakeWhile(x => x <= i))
            {
                if (i % p == 0)
                {
                    result[p] = 0;
                    var i2 = i;
                    while (i2 % p == 0)
                    {
                        result[p]++;
                        i2 /= p;
                    }
                }
            }
            return result;
        }

        public static Dictionary<long, int> Factor(long i, PrimeNumberGenerator primes)
        {
            var result = new Dictionary<long, int>();
            var primesList = primes.Primes().TakeWhile(x => x <= i).ToList();
            var primesCount = primesList.Count();
            long p = 0;
            for (int j = 0; j < primesCount; j++)
            {
                p = primesList[j];
                if (i % p == 0)
                {
                    result[p] = 0;
                    var i2 = i;
                    while (i2 % p == 0)
                    {
                        result[p]++;
                        i2 /= p;
                    }
                }
            }
            return result;
        }

        public static int NumDivisors(long i, PrimeNumberGenerator primes)
            => Factor(i, primes).Values.Product(x => x + 1);

        public static int ReverseInt(int i)
        {
            if (i < 0)
            {
                return -1 * ReverseInt(-1 * i);
            }

            var result = 0;
            while (i > 0)
            {
                result = result * 10 + i % 10;
                i /= 10;
            }
            return result;
        }

        public static IEnumerable<int> GeneratePalindromicIntegers(int numDigits)
        {
            Assure(numDigits % 2 == 0, "numDigits must be even");
            Assure(numDigits >= 2, "numDigits must be between 2 and 8");
            Assure(numDigits <= 8, "numDigits must be between 2 and 8");

            var seed = ((int)Math.Pow(10, numDigits / 2)) - 1;
            var term = ((int)Math.Pow(10, numDigits / 2 - 1));
            var mult = ((int)Math.Pow(10, numDigits / 2));

            while (seed >= term)
            {
                yield return seed * mult + Functions.ReverseInt(seed);
                seed--;
            }
        }

        //--------------------------------------------------
        // The sequence of triangle numbers is generated by adding the natural numbers. So
        // the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten
        // terms would be:  1, 3, 6, 10, 15, 21, 28, 36, 45, 55
        //
        // Triangle numbers don't need to be enumerated. They can be computed.
        //--------------------------------------------------
        public static int TriangleNumber(int termNumber)
            => (termNumber + 1) * termNumber / 2;

        public static int TriangleTermNumber(int number)
        {
            var guess = (int)Math.Sqrt(number * 2);

            if (number == TriangleNumber(guess))
            {
                return guess;
            }

            if (number == TriangleNumber(guess + 1))
            {
                return guess + 1;
            }

            if (number == TriangleNumber(guess - 1))
            {
                return guess - 1;
            }

            return 0;
        }

        public static bool IsTriangleNumber(int number)
            => TriangleTermNumber(number) > 0;

        public static int Product(this IEnumerable<int> items, Func<int, int> selector)
        {
            return items.Aggregate(1, (product, x) => product * selector(x));
        }

        public static long Product(this IEnumerable<long> items)
        {
            return items.Aggregate(1L, (product, x) => product * x);
        }

        public static long Product(this IEnumerable<long> items, Func<long, long> selector)
        {
            return items.Aggregate(1L, (product, x) => product * selector(x));
        }

        // Naming this "Assure" since "Assert" is already heavily used by xUnit
        private static void Assure(bool condition, string message)
        {
            if (!condition)
            {
                throw new Exception(message);
            }
        }

        public static long Factorial(long n)
        {
            if (n < 1L)
            {
                throw new ArgumentException();
            }

            var result = 1L;
            while (n > 1)
            {
                result *= n;
                n--;
            }

            return result;
        }

        public static BigInteger Factorial(BigInteger n)
        {
            if (n < 1)
            {
                throw new ArgumentException();
            }

            var result = new BigInteger(1);
            while (n > 1)
            {
                result *= n;
                n--;
            }

            return result;
        }
    }
}